# Git-yandex-practice

## Команды консоли.

_clip_ - команда для копирования в буфер обмена из файла указанном в аргументе: (где test.txt - файл, откуда было скопировано содержимое)

```bash
clip < test.txt
```

---

_cd_ - навигация по папкам. В аргумент принимает название папки: (где test - папка, в которую хотим перейти)

```bash
cd test/
```

---

_pwd_ - показывает путь до текущей директории, начиная с корневой:

```bash
pwd
```

---

_ls_ - показывает содержание текущей директории:

```bash
ls
```

Вызов команды _ls_ флагом _-a_ - показывает скрытые файлы:

```bash
ls -a
```

---

_mkdir_ - создать директорию (по умолчанию в текущей директории). В аргумент принимает название новой директории: (где test - название новой директории)

```bash
mkdir test/
```

---

_touch_ - создать файл (по умолчанию в текущей директории). В аргумент принимает название нового файла и так же принято писать расширение нового файла: (где test.txt - название нового файла)

```bash
touch test.txt
```

---

_cp_ - копирует файлы из одной директории в другую. Принимает 2 аргумента:

-   Название файла в текущей директории. (может быть несколько)
-   В какую директорию необходимо скопировать файлы.

В примере скопировали _test.txt_ из текущей директории в дочернюю директорию _src_.

```bash
cp test.txt ./src
```

---

_mv_ - перемещение файлов и директорий(может быть несколько). Принимает 2 аргумента:

-   Название файла для перемещения в текущей директории (может быть несколько)
-   В какую директорию необходимо переместить.

В примере переместили _test.txt_ из текущей директории в корневую _~_.

```bash
mv test.txt ~
```

---

_rm_ - удалить файл. В аргумент принимает название файла: (где test.txt - назваие файла)

```bash
rm test.txt
```

---

_rmdir_ - удалить пустую **!** директорию. В аргумент принимает название директории: (где test - название директории)

```bash
rmdir test/
```

---

_rm -r_ - удалить директорию с файлами. Флаг _-r_ означает, что команда _rm_ будет применена рекурсивно для каждой поддиректории.

Сначала будут удалены все файлы внутри одной директории, а затем сама директория,
до тех пор, пока не удалится указанная в аргументе директория: (где test - название директории)

```bash
rm -r test
```

---

_cat_ - вывести в консоль содержимое файла. В аргумент принимает название файла: (где test.txt - название файла)

```bash
cat test.txt
```

_echo_ - вывести в консоль строку, переданную в в аргумент:

```bash
echo "Привет!"
```

_echo_ может так же записывать с символами перенаправления вывода (_>>_), и тогда она запишет аргумент в файл, указанный вторым аргументом:

```bash
echo "Привет!" >> test.txt
```

Перенаправление - это в целом возможность всего bash'а, и его можно использовать с любой другой командой, которая выводит что-то на экран.
Одинарный символ _>_ тоже перенаправит вывод, но перед этим очистит файл:

```bash
echo "Привет!" > test.txt
```

## SSH-ключи:

_ssh-keygen -t ed25519 -C "email"_ - команда для генерации пары ssh-ключей: (ed25519 - кодировка ключа. она может быть разной)

```bash
ssh-keygen -t ed25519 -C "email"
```

Публичный ключ - шифрует данные. Им можно поделиться.

Приватный ключ - расшифровывает данные. Им НЕЛЬЗЯ делиться!

SSH-ключи позволяют предоставить доступ к интернет-ресурсам, как например к GitHub`у.

## GIT && GitHub.

Git - система контроля версий. Консольный инструмент - _CLI_.

GitHub - место хранения удаленных репозиториев. Это платформа, которая упрощает командное взаимодействие GIT`ом

## Команды GIT.

_git init_ - инициализирует гит в текущей директории:
.git папка скрыта, но её можно увидеть с помощью `ls -a`.

**При случайной инициализации** - можно удалить директорию .git с помощью `rm -r .git` и тогда папка "отгититься".

```bash
git init
```

---

_git remote add_ - связать удаленный репозиторий с локальным. В аргумент принимает 2 параметра:

-   Имя удаленного репозитория - обычно указывается origin.
-   Его URL

```bash
git remote add origin URL
```

---

_git remote -v_ - проверить связку удаленного и локального репозитория. Флаг _-v_ является сокращением от _--verbose_ (то есть, подробный, подробное описание):

```bash
git remote -v
```

---

_git add_ - подготовить файлы к сохранению. В аргументы принимает список файлов, которые нужно подготовить.
Или же можно подготовить всю текущую директории с помощью `.`, или же с помощью флага _--all_

```bash
git add . || git add --all || git add README.md
```

---

_git commit_ - сохранить файлы (закоммитить файлы). Обычно применяется с флагом _-m_ - данный флаг позволяет добавить информативное сообщение к коммиту.
Принимает в аргументы сообщение для коммита.

```bash
git commit -m "message"
```

---

_git push_ - отправить сохраненные файлы (коммит) в удаленный репозиторий: (где branch_name - имя ветки, в которую нужно отправить изменения)

```bash
git push origin branch_name
```

## Markdown.

`*cursive* || _cursive_` - сделать текст курсивным.

`**bold** || __bold__` - сделать текст жирным.

`~~crossed~~` - зачеркнутый текст.

`<br>` - сделать переход на новую строку (или 2 пробела).

`1. первый пункт  2. второй пункт` - создать нумированный список (цифры + пробел).

`( - || * ) первый пункт 
( - || * ) второй пункт ` - создать ненумированный список (1 символ в скобках + пробел).

## Ссылка:

`[Яндекс](https://yandex.ru)` - создание ссылки.

-   В квадратных скобках написано то, как будет отображаться ссылка.
-   В круглых - адрес ссылки.

`[Яндекс](https://yandex.ru "Яндекс!")` - после адреса ссылки можно написать в кавычках подсказку при наведении.

## Код:

` ```test``` ` - в тройных кавычках можно записать код.

Стоит указать язык после первой тройки.

Вторая (и последняя) тройка должна находится на отдельной строке.

## Коммиты

## Хеш - идентификатор коммита.

**Хеширование** - это способ преобразить набор данных и получить их _отпечаток_ (fingerprint - идентификатор).
Информация о коммите - это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий коммит.
Git хеширует инфомрацию о коммите с помощью алгоритма SHA-1.
Обычно хеш - небольшая строка, состоящая из цифр 0-9 и латинских буква A-F (регист не важен).
Если хеш получить дважды для одного и того же набор данных - то он будет одинаковый гарантировано.
Если что-то изменилось в исходных данных - то хеш тоже изменится (достаточно сильно изменится).

Git хранит таблицу соответствий _хеш -> информация о коммите_. Если есть хеш - есть информация и о авторе коммита, дате и содержимом коммита.
Хеш - основной идентификатор коммита.
Хеш можно передавать разным git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.
Все хеши и таблицу соответствий Git хранит в скрытой директории .git, внутри проекта.

## Исследуем лог

_git log_ - команда для отображения списка коммитов в проекте.

```bash
git log
```

Описание состоит из:

-   Строка из цифр и латинских букв (A-F) после слова коммит - хеш коммита.
-   Author - имя автора и его электронная почта.
-   Date - дата и время создания коммита.
-   В конце обычно находится сообщение коммита.

_git log --oneline_ - команда для получения сокращенного списка коммитов в проекте.

```bash
git log --oneline
```

Сокращенный хеш, полученный с помощью `git log --oneline`, можно использовать так же, как и обычный хеш.
Команда старается подобрать такую длину сокращенных хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идет речь.
Количество символов в сокращенном хеше - автоматически подбирается оптимальное количество.

## HEAD - всему голова.

_HEAD_ - один из служебных файлов папки .git. Он указывает на коммит, который был сделан последним (самый новый). <br>
Если вывести в консоль последние HEAD при помощи cat, то там будет ссылка на служебный файл (refs/heads/master). <br>
Если же заглянуть в этот файл, то можно увидеть хеш последнего коммита. <br>
Когда делается новый коммит - git обновляет refs/heads/master - записывает в него хеш последнего коммита. Соответственно, HEAD тоже обновляется. <br>
При работе с gitом указатель `HEAD` упоминается достаточно часто. Для команд, в которых используется аргументом хеш коммита - можно передать аргумент HEAD,
и .git поймет, что мы обращаемся к последнему коммиту. <br>

## Статусы файло в Git.

Одна из ключевых задач git - отслеживать изменение файлов в репозитории. Для этого каждый файл помечается каким-либо статусом:

-   untracked - неотслеживаемый. Гит видит, что такое файл существует, но не следит за изменениями в нем. У файла с этим статусом нет предыдущих версий.
-   staged - подготовленный к коммиту. После выполнения `git add` - файл попадает в "staged area", то есть в список файлов, которые попадут в коммит. Иногда состояния staged могут называть indexed или cached.
-   tracked - противоположность untracked. В этот статус попадают все файлы, которые уже были зафиксированы с помощью `git commit` или добавлен в staged area с помощью `git add`. То есть, в этом статусе все файлы, в которых гит отслеживает изменения.
-   modified - состояние modified означает, что git сравнил содержимое файла с последней сохраненной версией в проекте и нашел изменения.
    Для файлов со статусом staged и modified обычно не указывают, что они так же со статусом tracked, но это подразумевается.
    <br>
    Команда `git add` добавляет в staged area только текущее содерижмое файла. Если этот же файл будет изменен после попадания в staged area - содержимое файла не будет находится staged area. Git сообщает о таком посредством статуса modified. Чтобы снова добавить файл staged area - нужно вновь прописать команду `git add`
    <br>

Жизненный цикл файла в git:
<br>

-   Файл создан. Гит ещё не отслеживает изменения в этом файле (untracked).
-   Файл был добавлен в staged area с помощью `git add` (staged + tracked). Возможно файл изменили после добавления в staged area (staged, modified + tracked). Состояние staged и modified у одного и того же файла, но у разных его версий. После выполнения `git add` снова статус снова меняется (staged + tracked)
-   Сделали коммит с помощью команды `git commit` (tracked).
-   Изменили закомиченный файл (modified + tracked).
-   Снова добавили в staged area с помощью `git add` (staged + tracked).
-   Сделали коммит (tracked).

## Как читать git status.

`git status` - показывает только следующие состояния файлов:

-   _staged_ - файлы подготовлены к сохранению
-   _modified_ - файлы были изменены после
-   _untracked_ - неотслеживаемые файлы

_tracked_ статус не отслеживается, потому что каждый раз при `git status` выводились бы все файлы проекта.

## Оформление сообщений к коммитам.

При выводе команды `git log --oneline` умещается максимум 72 первых символа сообщения, поэтому хорошим тоном будет уместить все в 72 символа.
Сообщение коммита должно быть:

-   относительно коротким.
-   легкочитаемым.
-   информативным.

В корпоративном стиле в начале сообщения оыбчно указывают Jira-ID, а после текст сообщения:

```bash
git commit -m "LGS:259: Дополнить список пасхалок новыми числами"
```

Есть так же стандарт Convential Commits - он отличается качественной документацией и подробной проработкой.
Convential Commits предлагает следующий формат коммита `<type>: <message>`, где type - это тип изменений. Примерый типов изменений:

-   _feat_ - для новой функциональности
-   _fix_ - для исправления ошибок.
    Пример такого стиля может быть:

```bash
git commit -m "feat: добавить подсчет суммы заказов за неделю"
```

Помимо, встречается и GitHub-стиль. В Github можно вести так же и список задач. Если коммит закрывает или решает какую-то задачу - то в сообщении удобно указывать ссылку на неё. Для этого в сообщении коммита нужно написать `#<номер задачи>`. Пример:

```bash
git commit -m "Исправить #324, добавить график температуры"
```

## Mermaid-тест.

```mermaid
  graph TD;
      A-->B;
      A-->C;
      B-->D;
      C-->D;
```

## Как исправить коммит.

Иногда в только что созданном коммите нужно что-то поменять - например, добавить ещё пару файлов или заменить сообщение на другое.
Правки в уже сделанный коммит можно добавить с помощью опции `--amend` у команды `git commit`. <br>
`--amend` - работает только с последним коммитом (HEAD).
<br>
Дополнить коммит новыми файлами можно с помощью `git commit --amend -- no-edit`. C опцией `--amend` команда `git commit` не создаст новый коммит, а дополнит последний. Опция `--no-edit` же говорит о том, что сообщение коммита нужно оставить как было.
С помощью `git commit --amend --no-edit` можно так же добавить не новый файл, а исправленную версию того, который был в коммите до этого:

```bash
git add main.html
git commit --amend --no-edit
```

Возможно, вместо того, чтобы добавить или изменить файлы в коммите нужно просто поменять сообщение.
Для этого можно воспользоваться командой.:

```bash
git commit --amend -m "<Новое сообщение>"
```

Если же забыть добавить к `git commit --amend` один из флагов: `--no-edit` или `-m`, то Git предложит отредактировать сообщение коммита вручную.
Для этого он откроект текстовый редактор, который установлен в системе вручную.

## Как откатиться назад, если "все сломалось".

Чтобы убрать из staged area файл нужно использовать команду - `git restore --staged <file>`. (от англ. restore - восстановить).
Перевел test.txt из статуса staged обратно в untracked:

```bash
git restore --staged test.txt
```

Чтобы сбросить все файлы из staged обратно untracked/modified нужно прописать команду `git restore --staged .`.
Данная команда сбросит всю текущую директорию.

Чтобы "откатить" коммита - можно воспользоваться командой `git reset --hard <commit hash>`,
где commit hash - хэш коммита, на которой мы хотим откатиться. Например, если мы хотим убрать последний коммит, то нужно откатиться до предпоследнего коммита.

```bash
git reset --hard <commit hash>
```

Коммит, который мы перескачили был удален. Это может показать команда `git log`. Последующая разработка же будет вестить от коммита, на который мы перешли.
При работе с командой `git reset --hard <hash>` стоит быть осторожным!

Чтобы откатить файл, который находится и не в статусе staged, и не в tracked, а в untracked и modified, то можно воспользоваться командой `git restore <file>`.
Данная команда вернет файл к последней версии, которая была сохранена через `git commit` или `git add`.

**RESTORE РАБОТАЕТ С ФАЙЛАМИ, А RESET - С КОММИТАМИ**

## Просматрвиаем изменения в файлах.

`git diff` - команда git, которая позволяет увидеть изменения между коммитами или между коммитом и локальным репозиторием.
При введении команды `git diff` выведет изменения, произошедшие в локальном репозитории по отношению к последнему коммиту.

Как читать лог команды `git diff`:

-   строки `diff --git a/.. b/..` и `index 901da07..aca451 100644` - низкоуровненвая тех. информация.
-   строки ---a/test.txt и +++b/test.txt говорят о том, что дальше будет выведен результат сравнения файлов a/test.txt и b/test.txt - исходной и текущей версии.
-   строка `@@ -1,2 +1,2 @@` - говорит, что были использованы две строки, начиная с первой. Другой пример, +15,7 - это значит, что участвуют 7 строк начиная с 15-ой. `@@ +<с какой строки>,<сколько строк> @@`.

NOTE: Некоторый диапазон строк позволяет строк в `git diff` нужен для понимания контекста изменений - для чего и почему эти изменения были применены.

По-умолчанию команда `git diff` не показывает изменения в файлах, которые находятся в staged area.
Для того, чтобы посмотреть изменения в файлах со статусом staged нужно применить команду `git diff` с опцией `--staged`:

```bash
git diff --staged
```

## Сопоставляем коммиты.

с помощью команды `git diff` мы можем сравнивать два коммита, передав хэши коммитов в аргументы:

```bash
git diff <first commit hash> <second commit hash>
```

Если мы хоотим сравнить один из предыдущих коммитов с самым последним, то в качестве аргумента одного из хешей можно передать алиас HEAD, ибо он хранит в хеш самого последнего коммита.

По сути, команда `git diff A B` выведет, как превратить состояние A в состояние B.

## Игнорирование файлов в Git.

С точки зреня Git - .gitignore это обычный текстовый файл. Его тоже добавляют в корень репозитория и тоже коммитят.
В простейшем случае в .gitignore добавляют файлы (по одному имени на строку), которые нужно игнорировать, но можно использовать так же и шаблоны.

Правила из .gitignore применяются к новым (со статусом untracked) файлам. Если файл успел попасть в staged area или в коммит, то правила на него не распространяются.

_Комментарий_ - строка, начинающаяся с символа "#", которую .gitignore не будет учитывать.

```
# комментарий
```

Для запрета определенного файла - в .gitignore нужно добавить новую строку с названием файла, например, если в .gitignore-файле есть строка с test.txt, то файл с этим именем в корневой директории не будет учитываться.

```
# будет проигнорирован
test.txt
```

_Символ звездочки "\*"_ - соответствует любой строке, включая пустую. Если такой символ используется в шаблоне .gitignore, то файл будет проигнорирован вне зависимости от того, что находится на месте звездочки.

```
# проигнорирует все файлы с расширением .jpeg
*.jpeg

# проигнорирует все файлы test во всех подпапках docs
./docs/*/test
```

NOTE: Если в качестве шаблона указан просто символ _\*_, то Git проигнорирует вообще все файлы:

```
# проигнорирует все файлы
*
```

_Вопросительный знак_ - соответствует одному любому символу.

```
# будут проигнорированы файлы fileA.txt, file1.txt, file2.txt, но не будут проигнорированый файлы file12.txt, fileAB.txt, fileab.txt.
file?.txt
```

_Квадратные скобки_ - как и вопросительный знак, соответствует одному символу, но только это не любой символ, а один из указанных в скобках.

```
# Будут проигнорированы filep.txt, filez.txt, filea.txt, но не будут проигнорированы файлы file1.txt, fileab.txt, file12.txt, fileAB.txt
file[a-z].txt
```

В квадтраных скобках можно как перечислять символы [a,b,c], так и указать диапозон символа [a-z], [0-9], [b-s] и т.д.

_Слеш_ - слеш ("/") указывает на каталоги. Если шаблон .gitignore начинается со слеша, то Git проигнорирует файлы или каталоги только в корневой директории.

```
# файл будет проигнорирован только в корневом каталоге, так как / перед файлом указывает на нахождение в корневом каталоге.
/todo.txt

# файл будет проигнорирован во всем проекте.
spam.txt
```

Если же строка заканивается слешем, то правило применится только для директорий, но не для файлов. Например:

```
# проигнорирует только директории с именем build, но не будет трогать файлы с именем build.
build/
```

_Парные звездочки (\*\*)_ - парные звездочки похожи по функционалу на одинарные, отличие лишь в том, как они работают с вложенными папками. Двойная звездочка может соответсвовать любому количеству вложенных папок (и даже нулю), а одинарные - соответсвовать только одной.

```
# проигнорирует файлы tmp в следующих вариациях: docs/tmp, docs/test1/test2/test3/tmp, docs/smthng/tmp и т.д.
docs/**/tmp

# проигнорирует файлы tmp в следующих вариантах: docs/smthng/tmp, но не проигнорирует при следующих вариациях: docs/tmp, docs/smthng/test1/tmp и т.д.
docs/*/tmp
```

NOTE: для двойной звездочки верно такое же правило с игнорированием всех файлов, как и для одинарной звездочкой.

_Восклицательный знак_ - любое правило в .gitignore можно инвертировать с помощью "!". Такое обычно удобно для добавления исключений для файлов или директорий.

```
# проигнорирует все файлы с расширением .jpeg.
*.jpeg

# но мы добавили исключение для определенного файла. Файл doge.jpeg не будет проигнорирован.
!doge.jpeg
```

Игнорируемые файлы по-умолчанию не отображаются в выводе команды `git status`. Но все же если нужно отобразить игнорируемые файлы - существует опция `--ignored`, которая в отдельном разделе Ignored Files выведет все игнорируемые файлы.

```bash
git status --ignored
```

## Клонируем репозиторий.

Процесс копирование удаленного репозитория на локальный компьютер называется **клонированием**.

`git clone` - команда для клонирования репозитория.

```bash
git clone <repository url>
```

Клонированный репозиторий будет создан в репозитории, в котором находится пользователь.
Команда `git clone` автоматически свяжет удаленный и локальный репозитории.
Проверить наличие связки локального и удаленного репозитория можно с помощью команды `git remote -v`, где опция `-v` явялется сокращением от опции `--verbose` (от англ. "подробный").

## Выполняем Fork.
Fork (от англ. "развилка") - **GitHub** операция, напрямую с гитом она не связана.

В процессе _форка_ создается копия всех файлов, истории коммитов и веток. Эта копия сохраняется в учетной записи GitHub.
Форки применяются:
- Например, когда хочется внести изменения в open source проект, к которому нет прав на изменение исходного репозитория.
- Желание развивать проект независимо от исходного.

В результате форка - получится полная копия исходного репозитория, в которой можно свободно менять код.

**Fork - для копирования удаленного репозитория в СВОЙ АККАУНТ GitHub. Git clone - для копирования репозитория на ЛОКАЛЬНЫЙ КОМПЬЮТЕР!**

## Что такое ветка.
_Branch_ (по англ. "ветка") - это изолированный поток разработки проекта. В таком потоке можно проверять разные идеи, тестировать новую функциональность и т.д.

Коммиты, которые делает человек в своей ветке, не видны в других ветках. А когда работа в ветке будет закончена - можно будет соединить ветки.
Основная, стабильная версия проекта хранится в `main/master`. Обычно все новые ветки отходят от ветки `main/master`

`git branch` - команда, которая показывает все ветки проекта. Звездочкой помечена ветка, на которой вы сейчас находитесь.
```bash
git branch
```

## Создаем ветку.
`git branch <branch name>` - создать ветку. В параметры принимает название ветки.
```bash
git branch <branch name>
```

_/_ - в названии ветки не образует какую-либо иерархию. если при создании указано имя со слэшем - то ветка и будет создана с этим символом. Кроме слэша - название ветки может так же состоять из любых букв и цифр, а так же включать и другие 3 символа: ".", "-" и "_".

Название ветки должно описывать то, что происходит в этой ветке. <br>
Например - `feature/update-main-layout`, здесь есть ключевое слово, которое описывает всю задачу ветки:
- feature - новая функциональность, особенность, деталь.
- bugfix - ведется исправление ошибок.
После ключевого слова идет слэш и описание проблемы или задачи. Это описание не должно содержать пробелов, слова стоит разделить дефисом или нижним дефисом.

## Шагаем с ветки на ветку.
`git checkout <branch name>` - команда для переключения на другую ветку. В аргументы принимает название существующей ветки.
```bash
git checkout <branch name>
```
Вывод команды сообщает на какую ветку было произведено переключение.

Если прописать команду `git checkout` с опцией `-b` (от англ. "ветка" - branch) - `git checkout -b <branch name>`, то можно создать ветку и сразу переключиться на неё. Опция `-b` равносильная набору команд:
```bash
git branch <branch name> && git checkout <branch name>
```

Ветка в git - это указатель на коммит с той ветки, от которой была создана текущая. Когда делается коммит в новую ветку - указатель передвигается вперед.
Ветка указывает на коммит, который был сделан в ней последним.

## Сравнение веток.
Помимо сравнения изменения в коммитах - команда `git diff` так же позволяет сравнивать и ветки:

```bash
git diff <branch name first> <branch name second>
```

В качестве аргументов `git diff` может так же принимать хеши коммитов в ветке.
<br>
В git есть суффикс навигации - `~N`, где N - это число, которое отсчитывает определенное число назад от заданного коммита: `<hash commit or alias>~N`, или более обыденный пример `HEAD~1` - предыдущий от последнего коммита коммит, `HEAD~2` - предшествующий предыдущему коммит. Нумерация начинается с **нуля**, и например, `HEAD~0` будет равен просто последнему коммиту, то есть - `HEAD` и логики в такой записи нет.
<br>
Например, `main~5` - это пятый коммит ветки main, если считать с последнего выполненного коммита. В `git log` он будет шестым, потому что нумерация начинается с **0**.
<br>
Если указать суффикс навигации `~` без какого-либо числа `N`, то это значит, что он обращается к предыдущему от последнего коммита:

```bash
git diff HEAD~ HEAD
```
Это сравнение предпоследнего и последнего коммита

## Объединяем и удаляем ветки.
Мержить - объединять ветки.
<br>
Предварительно перед началом слияния веток стоит переийти на ветку, с которой нужно провести слияние с помощью команды: `git checkout <branch name>`
Чтобы выполнить слияние ветки нужно использовать команду - `git merge <branch name>`:

```bash
git merge <branch name>
```
После этой команды - все коммиты из `<branch name>` добавятся в ветку, в которой мы находимся.
В сообщении слияния будет показано:
- `Updating <commit hash 1>...<commit hash 2>` - означает, что коммиты с первого по второй были объединены.
- `Fast-forward` - режим слияния. Это значит, что создана линейная история коммитов. Такое происходит, если дочерняя ветка продолжает историю родительской.
- Информация о конкретных изменениях.
<br>
После слияния веток - ветку-донор можно удалить.
Предварительно нужно быть в главной ветке. Если же находится на ветке во время её удаления - git выдаст ошибку.
Чтобы удалить ветку - `git branch -D <branch name>`:

```bash
git branch -D <branch name>
```

- Флаг `-D` - сокращенная форма от `--delete --force`.
- Флаг `-d` - более безопасный вариант. Он удалит ветку, если только она была полностью объединена с другой. Данная команда подходит к случаям, когда случайно создается ветка с неправильным названием.
<br>
При удалении ветки с помощью команды `git branch -d || -D` - удалится только локальная ветка, а ветка на GitHub останется.

## Что такое конфликт.
Конфликты - ситуация, когда один или несколько человек модифицировали один и тот же файл, и при этом результаты совмещения оказались несовмистимы.
В таких случаях правильный случай может определить только человек.
<br>
Чтобы разрешить конфликт нужно:
- Заглянуть в файл, где произошёл конфликт.
- Изучить обе стороны конфликта — вашу версию и версию вашего коллеги. Ваша задача — правильно собрать две версии в итоговую, так чтобы изменения - обеих сторон не потерялись. Новая версия станет текущей актуальной.
- Вручную удалить или подправить неактуальные изменения, если они есть.
- Подготовить изменения к сохранению и сделать коммит.

## Обратно на GitHub.
Данная команда говорит о том, что была создана удаленная ветка и локальная теперь будет ссылаться на неё:
```bash
* [new branch]      feature/merge-request -> feature/merge-request
```

Если удалить ветку локально - она НЕ удаляется в удаленном репозитории.
Чтобы запушить локальную ветку НЕ обязательно быть на ней.

## Создаем Pull Request.
У каждого пул-реквеста есть:
- Название
- Описание
- Исходная ветка (откуда хотим взять изменения)
- Целевая ветка (куда хотим внести изменения)

Так же у каждого PR может быть два исхода:
- merge - предлагаемые изменения были внесены в целевую ветку.
- close - пул-реквест закрывается без слияния в целевую ветку.

Ссылка на создание PR выведется только один раз - при пуше новой ветки в удаленный репозиторий. При дальнейших пушах - ссылки на создание PR не будет.
PR можно сделать с момента, когда локальная ветка была запушена в удаленный репозиторий.
PR можно создать из любой ветки, которая отлична от целевой.

## Забираем изменения из удаленного репозитория.
Чтобы забрать изменения из удалённого репозитория - нужно воспользоваться командой `git pull` (от англ. pull - вытянуть):
```bash
git pull
```

Для того, чтобы использовать эту команду - нужно сначала переийти в нужную ветку, затем уже можно ввести команду.

Обычно перед созданием PR так же выполняют команды `git pull` и `git merge`. При работе в команде - главная ветка может успеть убежать вперед, пока изменения в новой ветке писались и подготовливались, и поэтому перед созданием PR нужно подтянуть изменения из основной ветки, объединить их с новой веткой, решить возможные конфликты и только потом выполнить команду `git push`.
Покомандно эту реализацию можно представить так:
```bash
git checkout main # перешли на главную ветку
git pull # подтянули новые изменения в локальную ветку main
git checkout <new-branch> # вернулись в рабочую локальную ветку
git merge main # влили ветку main в рабочую ветку
git push -u origin my-branch # зхапушили локальную ветку my-branch в удаленный репозиторий
```

Флаг `-u` в команде `git push` позволяет связать локальную и удаленную ветки.

Команда `git remote rm origin` - удалит текущую привязку `origin`:
```bash
git remote rm origin
```

Команда `git branch -a` - покажет все ветки в проекте, как удаленные, так и локальные:
```bash
git branch -a
```

Привязка между ветками с помомью флага -u нужна для будущего сокращения команд. Например, не нужно будет уточнять, куда надо запушить - вместо `git push origin <branch name>` можно будет использовать `git push`, потому что git будет знать, какие ветки между собой были связаны, и какой удаленной ветке соответствует рабочая локальная. То же самое и с командой `git pull`.