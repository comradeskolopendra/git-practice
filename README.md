# Git-yandex-practice

## Команды консоли.
*clip* - команда для копирования в буфер обмена из файла указанном в аргументе: (где test.txt - файл, откуда было скопировано содержимое)
```bash
clip < test.txt
```
---
*cd* - навигация по папкам. В аргумент принимает название папки: (где test - папка, в которую хотим перейти)
```bash
cd test/ 
```
---
*pwd* - показывает путь до текущей директории, начиная с корневой:
```bash
pwd
```
---
*ls* - показывает содержание текущей директории:
```bash
ls
```

Вызов команды *ls* флагом *-a* - показывает скрытые файлы:
```bash
ls -a
```
---
*mkdir* - создать директорию (по умолчанию в текущей директории). В аргумент принимает название новой директории: (где test - название новой директории)
```bash
mkdir test/
```
---
*touch* - создать файл (по умолчанию в текущей директории). В аргумент принимает название нового файла и так же принято писать расширение нового файла: (где test.txt - название нового файла)
```bash
touch test.txt
```
---
*cp* - копирует файлы из одной директории в другую. Принимает 2 аргумента:
- Название файла в текущей директории. (может быть несколько)
- В какую директорию необходимо скопировать файлы.

В примере скопировали *test.txt* из текущей директории в дочернюю директорию *src*.
```bash
cp test.txt ./src
```
---
*mv* - перемещение файлов и директорий(может быть несколько). Принимает 2 аргумента:
- Название файла для перемещения в текущей директории (может быть несколько)
- В какую директорию необходимо переместить.

В примере переместили *test.txt* из текущей директории в корневую *~*.
```bash
mv test.txt ~
```
---
*rm* - удалить файл. В аргумент принимает название файла: (где test.txt - назваие файла)
```bash
rm test.txt
```
---
*rmdir* - удалить пустую **!** директорию. В аргумент принимает название директории: (где test - название директории)
```bash
rmdir test/
```
---
*rm -r* - удалить директорию с файлами. Флаг *-r* означает, что команда *rm* будет применена рекурсивно для каждой поддиректории.

Сначала будут удалены все файлы внутри одной директории, а затем сама директория, 
до тех пор, пока не удалится указанная в аргументе директория: (где test - название директории)
```bash
rm -r test
```
---
*cat* - вывести в консоль содержимое файла. В аргумент принимает название файла: (где test.txt - название файла)
```bash
cat test.txt
```


## SSH-ключи:
*ssh-keygen -t ed25519 -C "email"* - команда для генерации пары ssh-ключей: (ed25519 - кодировка ключа. она может быть разной)
```bash
ssh-keygen -t ed25519 -C "email"
```

Публичный ключ - шифрует данные. Им можно поделиться.

Приватный ключ - расшифровывает данные. Им НЕЛЬЗЯ делиться!

SSH-ключи позволяют предоставить доступ к интернет-ресурсам, как например к GitHub`у.

## GIT && GitHub.
Git - система контроля версий. Консольный инструмент - *CLI*.

GitHub - место хранения удаленных репозиториев. Это платформа, которая упрощает командное взаимодействие GIT`ом


## Команды GIT.
*git init* - инициализирует гит в текущей директории:
.git папка скрыта, но её можно увидеть с помощью `ls -a`.


**При случайной инициализации** - можно удалить директорию .git с помощью `rm -r .git` и тогда папка "отгититься". 
```bash
git init
```
---
*git remote add* - связать удаленный репозиторий с локальным. В аргумент принимает 2 параметра:
- Имя удаленного репозитория - обычно указывается origin.
- Его URL
```bash
git remote add origin URL
```
---
*git remote -v* - проверить связку удаленного и локального репозитория. Флаг *-v* является сокращением от *--verbose* (то есть, подробный, подробное описание):
```bash
git remote -v
```
---
*git add* - подготовить файлы к сохранению. В аргументы принимает список файлов, которые нужно подготовить.
Или же можно подготовить всю текущую директории с помощью `.`, или же с помощью флага *--all*
```bash
git add . || git add --all || git add README.md
```
---
*git commit* - сохранить файлы (закоммитить файлы). Обычно применяется с флагом *-m* - данный флаг позволяет добавить информативное сообщение к коммиту.
Принимает в аргументы сообщение для коммита.
```bash
git commit -m "message"
```
---
*git push* - отправить сохраненные файлы (коммит) в удаленный репозиторий: (где branch_name - имя ветки, в которую нужно отправить изменения)
```bash
git push origin branch_name
```

## Markdown.
`*cursive* || _cursive_` - сделать текст курсивным.

`**bold** || __bold__` - сделать текст жирным.

`~~crossed~~` - зачеркнутый текст.

`<br>` - сделать переход на новую строку (или 2 пробела).

`1. первый пункт  2. второй пункт` - создать нумированный список (цифры + пробел).

`
( - || * ) первый пункт 
( - || * ) второй пункт 
` - создать ненумированный список (1 символ в скобках + пробел).

### Ссылка:
`[Яндекс](https://yandex.ru)` - создание ссылки. 

- В квадратных скобках написано то, как будет отображаться ссылка. 
- В круглых - адрес ссылки.

`[Яндекс](https://yandex.ru "Яндекс!")` - после адреса ссылки можно написать в кавычках подсказку при наведении.

### Код:
` ```test``` ` - в тройных кавычках можно записать код.

Стоит указать язык после первой тройки.

Вторая (и последняя) тройка должна находится на отдельной строке.

### Коммиты
#### Хеш - идентификатор коммита.
**Хеширование** - это способ преобразить набор данных и получить их *отпечаток* (fingerprint - идентификатор).
Информация о коммите - это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий коммит.
Git хеширует инфомрацию о коммите с помощью алгоритма SHA-1.
Обычно хеш - небольшая строка, состоящая из цифр 0-9 и латинских буква A-F (регист не важен).
Если хеш получить дважды для одного и того же набор данных - то он будет одинаковый гарантировано.
Если что-то изменилось в исходных данных - то хеш тоже изменится (достаточно сильно изменится).

Git хранит таблицу соответствий *хеш -> информация о коммите*. Если есть хеш - есть информация и о авторе коммита, дате и содержимом коммита.
Хеш - основной идентификатор коммита.
Хеш можно передавать разным git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.
Все хеши и таблицу соответствий Git хранит в скрытой директории .git, внутри проекта.

#### Исследуем лог
*git log* - команда для отображения списка коммитов в проекте.
```bash 
git log
```

Описание состоит из:
- Строка из цифр и латинских букв (A-F) после слова коммит - хеш коммита.
- Author - имя автора и его электронная почта.
- Date - дата и время создания коммита.
- В конце обычно находится сообщение коммита.

*git log --oneline* - команда для получения сокращенного списка коммитов в проекте.
```bash
git log --oneline
```

Сокращенный хеш, полученный с помощью `git log --oneline`, можно использовать так же, как и обычный хеш.
Команда старается подобрать такую длину сокращенных хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идет речь.
Количество символов в сокращенном хеше - автоматически подбирается оптимальное количество.

### HEAD - всему голова.
*HEAD* - один из служебных файлов папки .git. Он указывает на коммит, который был сделан последним (самый новый). <br>
Если вывести в консоль последние HEAD при помощи cat, то там будет ссылка на служебный файл (refs/heads/master). <br>
Если же заглянуть в этот файл, то можно увидеть хеш последнего коммита. <br>
Когда делается новый коммит - git обновляет refs/heads/master - записывает в него хеш последнего коммита. Соответственно, HEAD тоже обновляется. <br>
При работе с gitом указатель `HEAD` упоминается достаточно часто. Для команд, в которых используется аргументом хеш коммита - можно передать аргумент HEAD,
и .git поймет, что мы обращаемся к последнему коммиту. <br>

### Статусы файло в Git.
Одна из ключевых задач git - отслеживать изменение файлов в репозитории. Для этого каждый файл помечается каким-либо статусом:
- untracked - неотслеживаемый. Гит видит, что такое файл существует, но не следит за изменениями в нем. У файла с этим статусом нет предыдущих версий.
- staged - подготовленный к коммиту. После выполнения `git add` - файл попадает в "staged area", то есть в список файлов, которые попадут в коммит. Иногда состояния staged могут называть indexed или cached.
- tracked - противоположность untracked. В этот статус попадают все файлы, которые уже были зафиксированы с помощью `git commit` или добавлен в staged area с помощью `git add`. То есть, в этом статусе все файлы, в которых гит отслеживает изменения.
- modified - состояние modified означает, что git сравнил содержимое файла с последней сохраненной версией в проекте и нашел изменения.
Для файлов со статусом staged и modified обычно не указывают, что они так же со статусом tracked, но это подразумевается.
<br>
Команда `git add` добавляет в staged area только текущее содерижмое файла. Если этот же файл будет изменен после попадания в staged area - содержимое файла не будет находится staged area.
Git сообщает о таком посредством статуса modified. Чтобы снова добавить файл staged area - нужно вновь прописать команду `git add`
<br>
Жизненный цикл файла в git:
- Файл создан. Гит ещё не отслеживает изменения в этом файле (untracked).
- Файл был добавлен в staged area с помощью `git add` (staged + tracked). Возможно файл изменили после добавления в staged area (staged, modified + tracked). Состояние staged и modified у одного и того же файла, но у разных его версий. После выполнения `git add` снова статус снова меняется (staged + tracked)
- Сделали коммит с помощью команды `git commit` (tracked).
- Изменили закомиченный файл (modified + tracked).
- Снова добавили в staged area с помощью `git add` (staged + tracked).
- Сделали коммит (tracked).

### Как читать git status.
`git status` - показывает только следующие состояния файлов:
- *staged* - файлы подготовлены к сохранению
- *modified* - файлы были изменены после 
- *untracked* - неотслеживаемые файлы

*tracked* статус не отслеживается, потому что каждый раз при `git status` выводились бы все файлы проекта.